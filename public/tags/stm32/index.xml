<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>STM32 on OpenMicroLab</title><link>https://openmicrolab.com/tags/stm32/</link><description>Recent content in STM32 on OpenMicroLab</description><generator>Hugo -- gohugo.io</generator><language>ko</language><lastBuildDate>Fri, 26 Nov 2021 01:42:32 +0000</lastBuildDate><atom:link href="https://openmicrolab.com/tags/stm32/index.xml" rel="self" type="application/rss+xml"/><item><title>ST-LINK가 STM32CubeIDE에서의 오류</title><link>https://openmicrolab.com/st-link%EA%B0%80-stm32cubeide%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%A4%EB%A5%98/</link><pubDate>Fri, 26 Nov 2021 01:42:32 +0000</pubDate><guid>https://openmicrolab.com/st-link%EA%B0%80-stm32cubeide%EC%97%90%EC%84%9C%EC%9D%98-%EC%98%A4%EB%A5%98/</guid><description>
&lt;p>기존에 사용하던 ST-LINK가 있었고, 새로 구매한 ST-LINK를 연결해서 테스트를 하려고 했는데, 다음과 같은 에러 메시지가 보인다. ST-LINK의 펌웨어도 업데이트를 해보았으나 동일한 메시지가 계속 발생.&lt;/p>
&lt;p>&lt;a href="https://openmicrolab.com/images/2021/11/st-link1.png">&lt;img loading="lazy" class="aligncenter wp-image-4808" src="https://openmicrolab.com/images/2021/11/st-link1.png" alt="" width="471" height="114" srcset="https://openmicrolab.com/images/2021/11/st-link1.png 578w, https://openmicrolab.com/images/2021/11/st-link1-300x73.png 300w" sizes="(max-width: 471px) 100vw, 471px" />&lt;/a>&lt;/p>
&lt;p>디버그 설정에서 보니 ST-LINK S/N 에서 Scan을 하면 자동으로 리스트가 업데이트가 되는 것이 아니라, &lt;strong>리스트 중에 하나를 수동으로 선택 해야하는 것.&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://openmicrolab.com/images/2021/11/stm32cubeIDE.png">&lt;img loading="lazy" class="aligncenter wp-image-4809" src="https://openmicrolab.com/images/2021/11/stm32cubeIDE.png" alt="" width="574" height="527" srcset="https://openmicrolab.com/images/2021/11/stm32cubeIDE.png 803w, https://openmicrolab.com/images/2021/11/stm32cubeIDE-300x275.png 300w, https://openmicrolab.com/images/2021/11/stm32cubeIDE-768x705.png 768w" sizes="(max-width: 574px) 100vw, 574px" />&lt;/a>&lt;/p></description></item><item><title>STM32 USB 솔루션</title><link>https://openmicrolab.com/stm32-usb-%EC%86%94%EB%A3%A8%EC%85%98/</link><pubDate>Sun, 16 May 2021 07:33:01 +0000</pubDate><guid>https://openmicrolab.com/stm32-usb-%EC%86%94%EB%A3%A8%EC%85%98/</guid><description>
&lt;p>&lt;a href="https://openmicrolab.com/images/2021/05/STM32_USB.png">&lt;img loading="lazy" class="aligncenter wp-image-4740 size-large" src="https://openmicrolab.com/images/2021/05/STM32_USB-1024x737.png" alt="" width="1024" height="737" srcset="https://openmicrolab.com/images/2021/05/STM32_USB-1024x737.png 1024w, https://openmicrolab.com/images/2021/05/STM32_USB-300x216.png 300w, https://openmicrolab.com/images/2021/05/STM32_USB-768x553.png 768w, https://openmicrolab.com/images/2021/05/STM32_USB.png 1248w" sizes="(max-width: 1024px) 100vw, 1024px" />&lt;/a>&lt;/p></description></item><item><title>STM32 이클립스 환경에서 디버깅시 에러</title><link>https://openmicrolab.com/stm32-%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%94%94%EB%B2%84%EA%B9%85%EC%8B%9C-%EC%97%90%EB%9F%AC/</link><pubDate>Wed, 16 May 2018 09:15:28 +0000</pubDate><guid>https://openmicrolab.com/stm32-%EC%9D%B4%ED%81%B4%EB%A6%BD%EC%8A%A4-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EB%94%94%EB%B2%84%EA%B9%85%EC%8B%9C-%EC%97%90%EB%9F%AC/</guid><description>
&lt;p>Stm32Cube와 Eclipse의 조합으로 개발을 할때 연결된 보드를 디버깅시 다음과 같은 에러 메시지가 뜰 경우가 있다.&lt;/p>
&lt;img loading="lazy" class="alignnone wp-image-4300" src="https://res.cloudinary.com/openmicrolab/image/upload/c_scale,w_893/v1526461893/Eclipse_error_ffqlxo.png" width="485" height="299" />
&lt;p>이럴때는 프로젝트의 설정의 Run/Debug Setings의 Startup 탭에서 다음 그림에 보이는 2가지 항목의 설정을 해제하면 된다.&lt;/p>
&lt;img loading="lazy" class="alignnone wp-image-4301" src="https://res.cloudinary.com/openmicrolab/image/upload/v1526461892/Eclipse_debug_uu8snd.png" width="2102" height="1542" /></description></item><item><title>Nucleo 보드에서의 printf</title><link>https://openmicrolab.com/nucleo-%EB%B3%B4%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-printf/</link><pubDate>Thu, 26 Apr 2018 11:06:33 +0000</pubDate><guid>https://openmicrolab.com/nucleo-%EB%B3%B4%EB%93%9C%EC%97%90%EC%84%9C%EC%9D%98-printf/</guid><description>
&lt;img loading="lazy" class="alignnone wp-image-4290" src="https://res.cloudinary.com/openmicrolab/image/upload/v1524740338/IMG_6522_autbwr.jpg" width="361" height="361" />
&lt;p>임베디드 보드에서의 Hello World인 blink 테스트를 끝나면 printf를 찍기위해 UART를 연결하고 테스트를 한다. Nucleo 보드에서도 마찬가지로 작업을 하는데, 회로도를 보면 아두이노 핀 호환 컨넥터의 TX, RX핀에 연결이 되어있다. 하지만 자세히 회로도를 보면 default 연결은 이 핀들이 아니라 ST-Link칩에 연결이 되어 있다. 즉 UART2의 경우 ST-Link를 통해서 USB 컨넥터에 연결이되고 virtual COM port로 잡힌다. 매뉴얼에 보면 다음과 같이 나온다.&lt;/p>
&lt;blockquote>
&lt;p>The USART2 interface available on PA2 and PA3 of the STM32 microcontroller can be connected to ST-LINK MCU, ST morpho connector or to Arduino connector. The choice can be changed by setting the related solder bridges. By default the USART2 communication between the target STM32 and ST-LINK MCU is enabled, in order to support virtual COM port for MbedTM (SB13 and SB14 ON, SB62 and SB63 OFF). If the communication between the target STM32 PA2 (D1) or PA3 (D0) and shield or extension board is required, SB62 and SB63 should be ON, SB13 and SB14 should be OFF. In such case it is possible to connect another USART to ST-LINK MCU using flying wires between ST morpho connector and CN3.&lt;/p></description></item><item><title>System Workbench for STM32</title><link>https://openmicrolab.com/system-workbench-stm32/</link><pubDate>Thu, 01 Mar 2018 09:04:19 +0000</pubDate><guid>https://openmicrolab.com/system-workbench-stm32/</guid><description>
&lt;p>System Workbench for STM32를 설치하는 방법은 2가지이다. 인스톨 프로그램으로 설치하는 방법과 기존에 설치되어 있는 이클립스에 설치하는 방법이 있다.&lt;/p>
&lt;h3 id="인스톨-프로그램">&lt;strong>인스톨 프로그램&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>System Workbench for STM32를 &lt;a href="http://www.openstm32.org/Downloading%2Bthe%2BSystem%2BWorkbench%2Bfor%2BSTM32%2Binstaller" target="_blank" rel="noopener noreferrer">링크&lt;/a>에서 다운로드 한다.&lt;/li>
&lt;li>다운로드 받은 바이너리 파일의  퍼미션을 수정후 파일을 실행한다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>chmod 755 install_sw4stm32.run then ./install_sw4stm32.run&lt;/p>&lt;/blockquote>
&lt;img loading="lazy" class="alignnone wp-image-4222" src="https://res.cloudinary.com/openmicrolab/image/upload/v1519891095/System_Workbench_for_STM32_wlfr7n.png" width="568" height="431" />
&lt;p>문제는 이렇게 설치를 하다가 다음과 같은 에러메시지가 나오고 더 이상 진행이 되지 않는다.&lt;/p>
&lt;img loading="lazy" class="alignnone wp-image-4224" src="https://res.cloudinary.com/openmicrolab/image/upload/v1519892823/error_nqiihq.png" width="765" height="132" />
&lt;h3 id="이클립스에서-추가하는-방법">&lt;strong>이클립스에서 추가하는 방법&lt;/strong>&lt;/h3>
&lt;ul>
&lt;li>이클립스에서“Help &amp;raquo; Install New Software”를 선택&lt;/li>
&lt;li>&lt;a href="http://ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.update-site-v2">http://ac6-tools.com/Eclipse-updates/org.openstm32.system-workbench.update-site-v2&lt;/a>를 입력하고, 이름은 System Workbench for STM32 – Bare Machine edition으로 한다.&lt;/li>
&lt;/ul>
&lt;img loading="lazy" class="alignnone wp-image-4230" src="https://openmicrolab.com/images/2021/03/install_bo1tqe-1.png" width="633" height="511" />
&lt;ul>
&lt;li>인스톨 전에 다음과 같이 맥의 게이트키퍼를 disable후 설치를 하고, 설치후 enable한다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>#To disable&lt;br>
sudo spctl –master-disable&lt;br>
#To enable&lt;br>
sudo spctl –master-enable&lt;/p></description></item><item><title>SD 메모리 SPI로 제어하기 – 2</title><link>https://openmicrolab.com/sd-%EB%A9%94%EB%AA%A8%EB%A6%AC-spi%EB%A1%9C-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0-2/</link><pubDate>Thu, 19 Nov 2015 05:53:48 +0000</pubDate><guid>https://openmicrolab.com/sd-%EB%A9%94%EB%AA%A8%EB%A6%AC-spi%EB%A1%9C-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0-2/</guid><description>
&lt;p>지난번 포스팅 “&lt;a href="http://openmicrolab.com/sd-%EB%A9%94%EB%AA%A8%EB%A6%AC-spi%EB%A1%9C-%EC%A0%9C%EC%96%B4%ED%95%98%EA%B8%B0/" target="_blank">SD 메모리 SPI로 제어하기&lt;/a>“의 내용만으로는 부족하여 추가적으로 정리한다.&lt;/p>
&lt;p>SD 메모리 카드는 기본적으로 전원이 들어오면 SDIO로 동작을 한다. 따라서 대부분의 칩벤더에서는 SDIO인터페이스를 사용하는 예제를 제공하는데, SDIO가 없는 작은 MCU에서는 SPI를 사용해야 한다. 따라서 다음 그림과 같은 초기화 루틴이 필요하다.&lt;/p>
&lt;h3 id="spi모드에서-sd-메모리-초기화-루틴">SPI모드에서 SD 메모리 초기화 루틴&lt;/h3>
&lt;p>&lt;a href="http://elm-chan.org/docs/mmc/gx1/sdinit.png">&lt;img loading="lazy" class="aligncenter" src="http://elm-chan.org/docs/mmc/gx1/sdinit.png" alt="" width="850" height="920" />&lt;/a>&lt;/p>
&lt;h3 id="sd-메모리-커맨드">SD 메모리 커맨드&lt;/h3>
&lt;p>&lt;a href="https://openmicrolab.com/images/2015/11/How_to_Use_MMC_SDC.png">&lt;img loading="lazy" class="aligncenter size-full wp-image-3468" src="https://openmicrolab.com/images/2015/11/How_to_Use_MMC_SDC.png" alt="How_to_Use_MMC_SDC" width="1368" height="787" srcset="https://openmicrolab.com/images/2015/11/How_to_Use_MMC_SDC.png 1368w, https://openmicrolab.com/images/2015/11/How_to_Use_MMC_SDC-300x173.png 300w, https://openmicrolab.com/images/2015/11/How_to_Use_MMC_SDC-1024x589.png 1024w" sizes="(max-width: 1368px) 100vw, 1368px" />&lt;/a>&lt;/p>
&lt;ul>
&lt;li>1번: CS, MISO를 High로 하고 74개 이상의 SPI dummy clock을 전송한다.&lt;/li>
&lt;li>2번: CRC가 반드시 일치해야 한다.&lt;/li>
&lt;/ul>
&lt;p>위 표에서 CMD0은 0, CMD8은 8을 전송하는 형태이고, ACMD41은 CMD55를 전송후 CMD41를 전송하는 것이며, argument로 30번째 비트가 세트된 32비트를 전송한다.&lt;/p></description></item><item><title>STM32 – STM8 Embedded software solutions</title><link>https://openmicrolab.com/stm32-stm8-embedded-software-solutions/</link><pubDate>Mon, 12 Mar 2012 10:50:26 +0000</pubDate><guid>https://openmicrolab.com/stm32-stm8-embedded-software-solutions/</guid><description>
&lt;p>잘 정리된 STM32, STM8의 s/w solution 가이드&lt;/p>
&lt;p style="margin: 0px;">
&lt;p>
&lt;a href="https://openmicrolab.com/images/2012/03/stm32-stm8.png">&lt;img loading="lazy" class="aligncenter wp-image-4722 size-full" src="https://openmicrolab.com/images/2012/03/stm32-stm8.png" alt="" width="848" height="553" srcset="https://openmicrolab.com/images/2012/03/stm32-stm8.png 848w, https://openmicrolab.com/images/2012/03/stm32-stm8-300x196.png 300w, https://openmicrolab.com/images/2012/03/stm32-stm8-768x501.png 768w" sizes="(max-width: 848px) 100vw, 848px" />&lt;/a>
&lt;/p>
&lt;p>
위 그림에 있는 모든 내용들의 솔루션이 정리되어 있다.
&lt;/p>
&lt;p style="margin: 0px;">
&lt;a class="aligncenter" href="https://openmicrolab.com/images/1/cfile2.uf.113A493B4F5DD4BC33C7AD.pdf">cfile2.uf.113A493B4F5DD4BC33C7AD.pdf&lt;/a>
&lt;/p></description></item><item><title>STmicro의 Cortex M0 칩</title><link>https://openmicrolab.com/stmicro%EC%9D%98-cortex-m0-%EC%B9%A9/</link><pubDate>Mon, 12 Mar 2012 10:42:38 +0000</pubDate><guid>https://openmicrolab.com/stmicro%EC%9D%98-cortex-m0-%EC%B9%A9/</guid><description>
&lt;p>최근의 MCU vendor들은 너나 할 것 없이 ARM사의 Cortex 코아를 내장한 칩을 출시하고 있다.&lt;br>
Cortex M3를 필두로 M4, M0까지…&lt;br>
기존의 &lt;A title="[http://liketheocean.tistory.com/78]로 이동합니다." href="http://liketheocean.tistory.com/78" target=_blank>NXP&lt;/A>, &lt;A title="[http://liketheocean.tistory.com/77]로 이동합니다." href="http://liketheocean.tistory.com/77" target=_blank>Nuvoton&lt;/A>등 많은 MCU 벤더들이 이미 M0기반의 칩을 출시했듯이, 이번에 ST도 M3, M4에 이어 M0기반의 칩을 출시했다.&lt;br>
ST의 Press release 기사: &lt;a href="http://www.st.com/internet/com/press_release/p3275.jsp">http://www.st.com/internet/com/press_release/p3275.jsp&lt;/a>&lt;/p>
&lt;P style="MARGIN: 0px">
&lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile27.uf.1505A8344F5DD2D81A9FFA.PNG" class="aligncenter" width="683" height="746" alt="" filename="STM_CortexM0.PNG" filemime="image/jpeg" />
&lt;/P>좀 SRAM사이즈가 작은 듯하지만&amp;#8230;
&lt;p>CortexM0와 M3, ARM7 과의 비교자료는 이전 포스트 “&lt;A title="[http://liketheocean.tistory.com/75]로 이동합니다." href="http://liketheocean.tistory.com/75" target=_blank>Cortex M0 비교 자료&lt;/A>“참고..&lt;/p></description></item><item><title>STM32 Journal</title><link>https://openmicrolab.com/stm32-journal/</link><pubDate>Fri, 16 Dec 2011 07:04:14 +0000</pubDate><guid>https://openmicrolab.com/stm32-journal/</guid><description>
&lt;p>ST에서 발간하는 STM32 Journal 첫호입니다.&lt;/p>
&lt;P style="MARGIN: 0px">
&lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile25.uf.132E684B4EEAEA3B1294E5.PNG" class="aligncenter" width="473" height="351" alt="" filename="stm32 journal.PNG" filemime="image/jpeg" />
&lt;/P>
&lt;P style="MARGIN: 0px">
&lt;a href="https://openmicrolab.com/images/1/cfile24.uf.190D3B4B4EEAEA973742D8.pdf" class="aligncenter" filename="stm32_journal.pdf" filemime="application/pdf" />cfile24.uf.190D3B4B4EEAEA973742D8.pdf&lt;/a>
&lt;/P>주로 새로 출시한 STM32 F4에 대한 설명이 있습니다.
&lt;P style="MARGIN: 0px">
&lt;br /> Connectivity쪽 자료를 보면 아래 그림과 같은 테이블이 나옵니다.
&lt;/P>
&lt;P style="MARGIN: 0px">
아래 테이블을 보면 MCU에서 초당 처리해야할 패킷의 수가 수치적으로 나와 있습니다. 당연히 한 패킷당 바이트수가 작을 수록 처리해야할 패킷의 수가 많습니다. 100Mbps의 경우는 10Mbps의 경우의 10배이고&amp;#8230;&lt;br /> 그리고 괄호안의 수치는 각 Bandwidth를 만족하기위한 1 패킷을 처리하기 위해 걸리는 시간입니다.&lt;br /> 즉 MCU가 최소한 이정도 성능이 있어야 10M, 100Mbps를 만족한다는 것인데&amp;#8230;&lt;br /> &lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile23.uf.1418BC4C4EEAEB5621FF04.PNG" class="aligncenter" width="586" height="223" alt="" filename="STM_throughput.PNG" filemime="image/jpeg" />&lt;br /> uC/TCP-IP 스텍을 사용시 zero copy&amp;nbsp;아키텍쳐를 사용하여 dedicated memory에 비해 장점이 있다고 설명을 합니다.&lt;br /> &lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile23.uf.1318BC4C4EEAEB5620B1A1.PNG" class="aligncenter" width="552" height="399" alt="" filename="STM4_Figure.PNG" filemime="image/jpeg" />
&lt;/P></description></item><item><title>MCU 개발키트의 트랜드</title><link>https://openmicrolab.com/mcu-%EA%B0%9C%EB%B0%9C%ED%82%A4%ED%8A%B8%EC%9D%98-%ED%8A%B8%EB%9E%9C%EB%93%9C/</link><pubDate>Fri, 04 Nov 2011 10:48:27 +0000</pubDate><guid>https://openmicrolab.com/mcu-%EA%B0%9C%EB%B0%9C%ED%82%A4%ED%8A%B8%EC%9D%98-%ED%8A%B8%EB%9E%9C%EB%93%9C/</guid><description>
&lt;p>모든 MCU 벤더들은 자신들이 출시하는 반도체 칩 이외에 사용자가 이 칩을 잘 사용하도록reference board 또는 evaluation board 라고 칭하는 개발 키드를 제공을 한다. 전통적으로 이것은 아주 오랜 기간 동안 칩의 모든 기능을 테스트해 볼 수 있도록 구성이 되어 있어서 칩의 기능이 많을수록 상당히 복잡한 형태를 가지고 있다. 하지만 최근의 경우 MCU 벤더들이 출시하는 칩의 종류는 메모리 용량 및 주변 장치에 따라 수십에서 수백 종에 이르므로 이 모든 칩을 위한 개발키트를 출시한다는 것은 거의 불가능하다. &lt;/p></description></item><item><title>Migrating from version 4.x to version 5.x</title><link>https://openmicrolab.com/migrating-from-version-4x-to-version-5x/</link><pubDate>Fri, 28 Jan 2011 05:37:31 +0000</pubDate><guid>https://openmicrolab.com/migrating-from-version-4x-to-version-5x/</guid><description>
&lt;p>&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">EWARM 4.x =&amp;gt; 5.0으로 갈아 타기위한 가이드 문서입니다.&lt;/SPAN>&lt;/SPAN>&lt;/p>
&lt;p>&lt;/FONT>&lt;a href="https://openmicrolab.com/images/1/cfile27.uf.173906564D425352191FFC.pdf" class="aligncenter" filename="EWARM_MigrationGuide.ENU.pdf" filemime="application/pdf" />cfile27.uf.173906564D425352191FFC.pdf&lt;/a>&lt;br>
&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile5.uf.1217D7544D4254002312D1.jpg" class="aligncenter" width="680" height="614" alt="" filename="EWARM.jpg" filemime="image/jpeg" />&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">소스를 그룹별로 정리를 해서 프로젝트를 만들었는데,&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">-. CMSIS – ARM의 CMSIS 관련 소스&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">-. EWARMv5.4 – CMSIS에서 지원하는 device 중 ST 라이브러리 소스&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">   사용하는 디바이스에 맞는 소스를 넣어준다.&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;/FONT>&lt;/p>
&lt;P style="MARGIN-LEFT: 1in" class=MsoNormal>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_ld_vl.s: &amp;nbsp; &amp;nbsp;for STM32 Low density Value line devices&lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/FONT>&lt;/SPAN>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_ld.s: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for STM32 Low density devices&lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/FONT>&lt;/SPAN>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_md_vl.s: &amp;nbsp;for STM32 Medium density Value line devices&lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/FONT>&lt;/SPAN>&lt;FONT color=#000000>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_md.s: &amp;nbsp; &amp;nbsp; &amp;nbsp;for STM32 Medium density devices &lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/SPAN>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_hd_vl.s:&amp;nbsp;&amp;nbsp; for&amp;nbsp;STM32 High density Value line devices&lt;/SPAN>&lt;/SPAN>&lt;/SPAN>
&lt;/FONT>&lt;FONT color=#000000>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_hd.s: &amp;nbsp; &amp;nbsp; &amp;nbsp; for&amp;nbsp;STM32 High density devices&lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/SPAN>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_xl.s: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for&amp;nbsp;STM32 XL density devices&lt;/SPAN>&lt;/SPAN>&lt;/SPAN>&lt;/FONT>&lt;FONT color=#000000>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt"> &lt;/SPAN>&lt;/SPAN>&lt;br /> &lt;/SPAN>&lt;SPAN style="FONT-FAMILY: Arial; FONT-SIZE: 10pt">&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">&amp;#8211; startup_stm32f10x_cl.s: &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;for&amp;nbsp;STM32 Connectivity line devices &lt;/SPAN>&lt;/SPAN>&lt;?xml:namespace prefix = o ns = "urn:schemas-microsoft-com:office:office" />&lt;o:p>&lt;/o:p>&lt;/SPAN>&lt;/FONT>
&lt;p>&lt;FONT color=#000000>&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">-. StdPeriph_Driver –  ST에서 제공하는 페리페럴 드라이버 소스, 사용하는 드라이버 만 올리면 된다. &lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;SPAN style="FONT-SIZE: 9pt">&lt;SPAN style="FONT-SIZE: 10pt">-. USER – 이건 사용자 소스&lt;/SPAN>&lt;/SPAN>&lt;br>
&lt;/FONT>&lt;/p></description></item><item><title>STM32 Peripheral power consumption</title><link>https://openmicrolab.com/stm32-peripheral-power-consumption/</link><pubDate>Tue, 25 Jan 2011 07:01:00 +0000</pubDate><guid>https://openmicrolab.com/stm32-peripheral-power-consumption/</guid><description>
&lt;p>&lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile4.uf.1960E4584D3E7496131E66.jpg" class="aligncenter" width="502" height="680" alt="" filename="STM32_power_consumption.jpg" filemime="image/jpeg" />위 표에서 볼 수 있듯이 APB1은 HCLK을 2분주해서 사용을 하고 APB2는 HCLK를 그대로 사용을 합니다.&lt;br>
따라서 APB2에 연결된 페리페럴이 더 빠르게 동작하며 전류 소비도 더 큽니다.&lt;br>
ADC는 역시 아날로그 파트라 전류 소비가 크군요.&lt;/p></description></item><item><title>EWARM4.42에 STM32 디바이스 추가하기</title><link>https://openmicrolab.com/ewarm442%EC%97%90-stm32-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/</link><pubDate>Tue, 04 Jan 2011 02:15:42 +0000</pubDate><guid>https://openmicrolab.com/ewarm442%EC%97%90-stm32-%EB%94%94%EB%B0%94%EC%9D%B4%EC%8A%A4-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/</guid><description>
&lt;p>첨부 파일의 readme.txt를 확인후 해당 파일을 IAR이 설치된 폴더에 업데이트 한다.&lt;/p>
&lt;p>&lt;a href="https://openmicrolab.com/images/1/cfile24.uf.1763C5594D22813614ECBC.zip" class="aligncenter" filename="stm32f10x_update_for_ewarm4.42.zip" filemime="application/zip" /> cfile24.uf.1763C5594D22813614ECBC.zip&lt;/a>&lt;br>
그러면 다음 그림과 같이 STM32F10xx 시리즈가 추가된다.&lt;/p>
&lt;img loading="lazy" src="https://openmicrolab.com/images/1/cfile25.uf.116203594D22828F18C958.jpg" class="aligncenter" width="640" height="417" alt="" filename="iar_ST.jpg" filemime="image/jpeg" /></description></item></channel></rss>